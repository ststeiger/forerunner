using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web.Script.Serialization;
using System.Collections.ObjectModel;

namespace Forerunner.SSRS
{
    public class SkipFieldsConverter : JavaScriptConverter
    {
        private IList<string> skipList;
        private IEnumerable<Type> supportedTypes;

        /// <summary>
        /// Implements a specialization of the JavaScriptConverter class.
        /// </summary>
        /// <param name="fields"></param>
        /// Array of field names to skip when serializing
        /// <param name="types"></param>
        /// Array of data types to process when serializing
        /// <returns></returns>
        public SkipFieldsConverter(string [] fields, Type[] types)
        {
            skipList = new List<string>(fields);
            supportedTypes = new ReadOnlyCollection<Type>(new List<Type>(types));
        }

        public override object Deserialize(IDictionary<string, object> dictionary, Type type, JavaScriptSerializer serializer)
        {
            throw new NotImplementedException();
        }

        public override IDictionary<string, object> Serialize(object obj, JavaScriptSerializer serializer)
        {
            var result = new Dictionary<string, object>();

            foreach (var prop in obj.GetType().GetProperties())
            {
                bool skipItem = skipList.Contains(prop.Name);
                if (!skipItem)
                {
                    if (prop.GetGetMethod() != null)
                    {
                        var value = prop.GetGetMethod(false).Invoke(obj, null);
                        result.Add(prop.Name, value);
                    }
                }
            }

            return result;
        }

        public override IEnumerable<Type> SupportedTypes
        {
            get { return supportedTypes; }
        }
    }

    public class ParamsList
    {
        public string Parameter { get; set; }
        public string IsMultiple { get; set; }
        public string Type { get; set; }
        public object Value { get; set; }
    }

    public class Data
    {
        public List<ParamsList> ParamsList { get; set; }
    }

    public class ParameterSet
    {
        public ParameterSet()
        {
            data = new Data();
        }

        public bool isAllUser { get; set; }
        public string name { get; set; }
        public string id { get; set; }
        public Data data { get; set; }
    }

    public class ParameterModel
    {
        public enum AllUser
        {
            IsAllUser,
            NotAllUser,
            KeepDefinition
        }

        public enum GeneratedFields
        {
            Include,    // Include generated fields (used when the client calls get)
            Exclude     // Exclude generated fields (used when the client calls save)
        }

        public bool canEditAllUsersSet { get; set; }
        public string defaultSetId { get; set; }
        public Dictionary<string, ParameterSet> parameterSets { get; set; }

        public ParameterModel()
        {
            canEditAllUsersSet = false;
            parameterSets = new Dictionary<string, ParameterSet>();
        }

        public ParameterModel(bool startingCanEditAllUsersSet)
        {
            canEditAllUsersSet = startingCanEditAllUsersSet;
            parameterSets = new Dictionary<string, ParameterSet>();
        }

        public string GetUserParameters(GeneratedFields option)
        {
            ParameterModel model = new ParameterModel(canEditAllUsersSet);

            model.canEditAllUsersSet = canEditAllUsersSet;
            model.defaultSetId = defaultSetId;
            model.parameterSets = parameterSets.Where(set => !set.Value.isAllUser).ToDictionary(pair => pair.Key, pair => pair.Value);
            return model.ToJson(option);
        }

        public string GetAllUserParameters(GeneratedFields option)
        {
            ParameterModel model = new ParameterModel(canEditAllUsersSet);

            model.canEditAllUsersSet = canEditAllUsersSet;
            model.parameterSets = parameterSets.Where(set => set.Value.isAllUser).ToDictionary(pair => pair.Key, pair => pair.Value);
            return model.ToJson(option);
        }

        public string ToJson(GeneratedFields option)
        {
            StringBuilder buffer = new StringBuilder();
            JavaScriptSerializer serializer = new JavaScriptSerializer();

            if (option == GeneratedFields.Exclude)
            {
                // Do not include fields that are generated by the server in the database
                string[] fields = { "canEditAllUsersSet", "isAllUser" };
                Type[] types = { typeof(ParameterModel), typeof(ParameterSet) };
                serializer.RegisterConverters(new JavaScriptConverter[] { new SkipFieldsConverter(fields, types) });
            }

            serializer.Serialize(this, buffer);

            return buffer.ToString();
        }

        public void Merge(ParameterModel newModel)
        {
            canEditAllUsersSet = canEditAllUsersSet || newModel.canEditAllUsersSet;
            if (newModel.defaultSetId != null && newModel.defaultSetId.Length > 0)
            {
                defaultSetId = newModel.defaultSetId;
            }
            parameterSets = parameterSets.Concat(newModel.parameterSets).ToDictionary(pair => pair.Key, pair => pair.Value);
        }

        static public ParameterModel parse(string savedParams, AllUser allUser, bool canEditAllUsersSet)
        {
            JavaScriptSerializer serializer = new JavaScriptSerializer();
            ParameterModel newModel = serializer.Deserialize<ParameterModel>(savedParams);

            newModel.canEditAllUsersSet = canEditAllUsersSet;
            if (allUser != AllUser.KeepDefinition)
            {
                foreach (KeyValuePair<string, ParameterSet> pair in newModel.parameterSets)
                {
                    pair.Value.isAllUser = allUser == AllUser.IsAllUser;
                }
            }

            return newModel;
        }
    }
}
